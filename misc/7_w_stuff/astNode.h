#pragma once

#include "posException.h"
#include "bigint.h"

#include <memory>


class AstNode {
    Pos pos_;

public:
    Pos pos() { return pos_; }

protected:
    explicit AstNode(Pos pos) : pos_(pos) {}
};
using AstNodePtr = std::unique_ptr<AstNode>;

struct EvalObject : public AstNode {
    virtual bool boolValue() const = 0;
    explicit EvalObject(Pos pos) : AstNode(pos) {}
};
using EvalObjectPtr = std::unique_ptr<EvalObject>;


// doesn't get generated by the parser
class Builtin : public EvalObject {
    using Fun = EvalObjectPtr (*) (const EvalObjectPtr& in);
    Fun val;
    std::string name;

public:
    bool boolValue() const override { return true; }

    Builtin(Fun val, const std::string& name)
            : EvalObject(0), val(val), name(name) {}

    EvalObjectPtr call(const EvalObjectPtr& arg) const { return val(arg); }
};

class Int : public EvalObject {
    BigInt val;
public:
    bool boolValue() const override { return !val.isZero(); }
    Int(Pos pos, const BigInt& val) : EvalObject(pos), val(val) {}
    Int(Pos pos, BigInt&& val) : EvalObject(pos), val(std::move(val)) {}
};

class Binary : public AstNode {
    using Fun = BigInt (*) (const BigInt& a, const BigInt& b);

    AstNodePtr a, b;
    Fun fun;
    std::string op;

public:
    Binary(Pos pos, const std::string& op, Fun fun, AstNodePtr&& a, AstNodePtr&& b)
            : AstNode(pos), a(std::move(a)), b(std::move(b)), fun(fun), op(op) {}
};

class Unary : public AstNode {
    using Fun = BigInt (*) (const BigInt& a);

    AstNodePtr a;
    Fun fun;
    std::string op;

public:
    Unary(Pos pos, const std::string& op, Fun fun, AstNodePtr&& a)
            : AstNode(pos), a(std::move(a)), fun(fun), op(op) {}
};

class Variable : public AstNode {
    std::string name;
public:
    Variable(Pos pos, const std::string& name) : AstNode(pos), name(name) {}
};
class FunCall : public AstNode {
    AstNodePtr fun, arg;
public:
    FunCall(Pos pos, AstNodePtr&& fun, AstNodePtr&& arg)
            : AstNode(pos), fun(std::move(fun)), arg(std::move(arg)) {}
};
class Lambda : public EvalObject {
    std::string param;
    AstNodePtr body;
public:
    Lambda(Pos pos, const std::string& param, AstNodePtr&& body)
            : EvalObject(pos), param(param), body(std::move(body)) {}
    bool boolValue() const override { return true; }
    // EvalObjectPtr call(const EvalObjectPtr& arg, Evaluator& eval) {
    //     return eval.Eval(body.withBoundVariable(param, arg));
    // }
};
class Assign : public AstNode {
    std::string name;
    AstNodePtr val;
public:
    Assign(Pos pos, const std::string& name, AstNodePtr&& val)
            : AstNode(pos), name(name), val(std::move(val)) {}
};

template<bool IsOr>
class BoolOp : AstNode {
    AstNodePtr a, b;
public:
    BoolOp(Pos pos, AstNodePtr&& a, AstNodePtr&& b)
            : AstNode(pos), a(std::move(a)), b(std::move(b)) {}
};
class If : AstNode {
    AstNodePtr cond, t, f;

public:
    If(Pos pos, AstNodePtr&& cond, AstNodePtr&& t, AstNodePtr&& f)
            : AstNode(pos), cond(std::move(cond)),
              t(std::move(t)), f(std::move(f)) {}
};
template<typename T>
struct AstVisitor {
    T Visit(Int v) = 0;
    T Visit(Binary v) = 0;
    T Visit(Unary v) = 0;
    T Visit(Variable v) = 0;
    T Visit(FunCall v) = 0;
    T Visit(Lambda v) = 0;
    T Visit(Assign v) = 0;
    T Visit(BoolOp<true> v) = 0;
    T Visit(BoolOp<false> v) = 0;
    T Visit(If v) = 0;
    T Visit(Builtin v) = 0;
};

		public string ToStringTree(int level = 0)
        {
			var indent = new string(' ', level*2);
			if (level != 0) indent += "| ";
			string PrintChildren(params AstNode[] nodes)
            {
				string res ="\n";
				foreach (var n in nodes)
					res += n.ToStringTree(level+1);
				return res;
			}
			return indent + this switch {
				Int v => $"int: {v.val}\n",
				Binary v => $"binary: "+PrintChildren(v.a, v.b),
				Unary v => $"unary: "+PrintChildren(v.a),
				Variable v => $"var '{v.name}'\n",
				FunCall v => $"funCall: "+PrintChildren(v.fun, v.arg),
				Lambda v => $"lambda {v.param}: "+PrintChildren(v.body),
				Assign v => $"assign {v.name}:"+PrintChildren(v.val),
				Or v => $"or: "+PrintChildren(v.a, v.b),
				And v => $"and: "+PrintChildren(v.a, v.b),
				If v => $"if: "+PrintChildren(v.cond, v.t, v.f),
				_ => ToString() +"\n",
			};
			//return indent+ impl.Visit((dynamic)this);
		}
		public override string ToString()
        {
			return this switch {
				Int v => v.val.ToString(),
				Binary v => $"({v.a} {v.op} {v.b})",
				Unary v => $"({v.op} {v.a})",
				Variable v => $"{v.name}",
				FunCall v => $"({v.fun} {v.arg})",
				Lambda v => $"Î»{v.param}. {v.body}",
				Assign v => $"{v.name} = {v.val}",
				Or v => $"({v.a} || {v.b})",
				And v => $"({v.a} && {v.b})",
				If v => $"({v.cond} ? {v.t} : {v.f})",
				Builtin v => "function {v.name}",
				_ => throw new NotImplementedException(),
			};
		}
		// replacing the variable directly should be fine since
		// we don't carry any state with our `EvalObject`s
		// only downside is that we can't reassign the parameter
		AstNode WithBoundVariable(string param, AstNode arg)
        {
			AstNode I(AstNode n) => n.WithBoundVariable(param, arg);

			var res = this switch {
				Int v => v,
				Binary v => new Binary(pos, v.op, v.fun, I(v.a), I(v.b)),
				Unary v => new Unary(pos, v.op, v.fun, I(v.a)),
				Variable v => (v.name == param ) ? arg : v,
				FunCall v => new FunCall(pos, I(v.fun), I(v.arg)),
				Lambda v when v.param == param => v,
                Lambda v => new Lambda(pos, v.param, I(v.body)),
				Assign v when v.name == param =>
					throw new EvalException(pos, "Can't reassign parameter"),
				Assign v => new Assign(pos, v.name, I(v.val)),
				Or v => new Or(pos, I(v.a), I(v.b)),
				And v => new And(pos, I(v.a), I(v.b)),
				If v => new If(pos, I(v.cond), I(v.t), I(v.f)),
				Builtin b => b,
				_ => throw new NotImplementedException(),
			};
            // Console.WriteLine($"bound {param} = {res}");
            return res;
		}
	}
}

