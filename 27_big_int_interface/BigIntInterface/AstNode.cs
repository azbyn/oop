using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace BigIntInterface
{
	using Pos = Int32;

	public abstract class AstNode
	{
		public readonly Pos pos;

		protected AstNode(Pos pos) { this.pos = pos; }

		public abstract class EvalObject : AstNode
		{
			public abstract  bool BoolValue { get; }
			public EvalObject(Pos pos) : base(pos) {}
		}
		//doesn't get generated by the parser
		public class Builtin : EvalObject
		{
			readonly Func<EvalObject, EvalObject> val;
			readonly string name;
			public override bool BoolValue => true;

			public Builtin(Func<EvalObject, EvalObject> val, string name) : base(0)
			{
				this.val = val;
				this.name = name;
			}
			public EvalObject Call(EvalObject arg) => val(arg);

			public override string ToString() => $"Function {name} ";
		}


		public class Int : EvalObject
		{
			public readonly BigInt val;
			public override bool BoolValue => !val.IsZero;
			public Int(Pos pos, string val) : this(pos, (BigInt) val) { }
			public Int(Pos pos, BigInt val) : base(pos) { this.val = val; }

			public override string ToString() => val.ToString();
		}

		public class Binary : AstNode
		{
			public delegate BigInt Fun(BigInt a, BigInt b);
			public readonly AstNode a, b;
			public readonly Fun fun;
			public readonly string op;

			public Binary(Pos pos, string op, Fun fun, AstNode a, AstNode b) : base(pos) 
            {
				this.fun = fun;
				this.a = a;
				this.b = b;
				this.op = op;
			}
		}

		public class Unary : AstNode
		{
			public delegate BigInt Fun(BigInt a);
			public readonly AstNode a;
			public readonly Fun fun;
			public readonly string op;

			public Unary(Pos pos, string op, Fun fun, AstNode a) : base(pos) 
            {
				this.fun = fun;
				this.a = a;
				this.op = op;
			}
		}

		public class Variable : AstNode
		{
			public readonly string name;
			public Variable(Pos pos, string name) : base(pos) 
            {
                this.name = name;
			}
		}
		public class FunCall : AstNode
		{
			public readonly AstNode fun;
			public readonly AstNode arg;
			public FunCall(Pos pos, AstNode fun, AstNode arg) : base(pos) 
            {
				this.fun = fun;
				this.arg = arg;
			}
		}
		public class Lambda : EvalObject
		{
			public readonly string param;
			public readonly AstNode body;
			public Lambda(Pos pos, string param, AstNode body) :base(pos) 
            {
				this.param = param;
				this.body = body;
			}

			public override bool BoolValue => true;
			public EvalObject Call(EvalObject arg, Evaluator eval)
				=> eval.Eval(body.WithBoundVariable(param, arg));
		}
		public class Assign : AstNode
        {
			public readonly string name;
			public readonly AstNode val;
			public Assign(Pos pos, string name, AstNode val) : base(pos) 
            {
				this.val = val;
				this.name = name;
			}
		}

		public class Or : AstNode
        {
			public readonly AstNode a, b;
			public Or(Pos pos, AstNode a, AstNode b) :base(pos) 
            {
				this.a = a;
				this.b = b;
			}
		}
		public class And : AstNode
        {
			public readonly AstNode a, b;
			public And(Pos pos, AstNode a, AstNode b) :base(pos) 
            {
				this.a = a;
				this.b = b;
			}
		}
		public class If : AstNode 
        {
			public readonly AstNode cond, t, f;
			public If(Pos pos, AstNode cond, AstNode t, AstNode f) :base(pos) 
            {
				this.t = t;
				this.f = f;
				this.cond = cond;
			}
		}
		public interface IVisitor<T>
        {
			T Visit(Int v);
			T Visit(Binary v);
			T Visit(Unary v);
			T Visit(Variable v);
			T Visit(FunCall v);
			T Visit(Lambda v);
			T Visit(Assign v);
			T Visit(Or v);
			T Visit(And v);
			T Visit(If v);
			T Visit(Builtin v);
		}

		public string ToStringTree(int level = 0)
        {
			var indent = new string(' ', level*2);
			if (level != 0) indent += "| ";
			string PrintChildren(params AstNode[] nodes)
            {
				string res ="\n";
				foreach (var n in nodes)
					res += n.ToStringTree(level+1);
				return res;
			}
			return indent + this switch {
				Int v => $"int: {v.val}\n",
				Binary v => $"binary: "+PrintChildren(v.a, v.b),
				Unary v => $"unary: "+PrintChildren(v.a),
				Variable v => $"var '{v.name}'\n",
				FunCall v => $"funCall: "+PrintChildren(v.fun, v.arg),
				Lambda v => $"lambda {v.param}: "+PrintChildren(v.body),
				Assign v => $"assign {v.name}:"+PrintChildren(v.val),
				Or v => $"or: "+PrintChildren(v.a, v.b),
				And v => $"and: "+PrintChildren(v.a, v.b),
				If v => $"if: "+PrintChildren(v.cond, v.t, v.f),
				_ => ToString() +"\n",
			};
			//return indent+ impl.Visit((dynamic)this);
		}
		public override string ToString()
        {
			return this switch {
				Int v => v.val.ToString(),
				Binary v => $"({v.a} {v.op} {v.b})",
				Unary v => $"({v.op} {v.a})",
				Variable v => $"{v.name}",
				FunCall v => $"({v.fun} {v.arg})",
				Lambda v => $"λ{v.param}. {v.body}",
				Assign v => $"{v.name} = {v.val}",
				Or v => $"({v.a} || {v.b})",
				And v => $"({v.a} && {v.b})",
				If v => $"({v.cond} ? {v.t} : {v.f})",
				Builtin v => "function {v.name}",
				_ => throw new NotImplementedException(),
			};
		}
		// replacing the variable directly should be fine since
		// we don't carry any state with our `EvalObject`s
		// only downside is that we can't reassign the parameter
		AstNode WithBoundVariable(string param, AstNode arg)
        {
			AstNode I(AstNode n) => n.WithBoundVariable(param, arg);

			var res = this switch {
				Int v => v,
				Binary v => new Binary(pos, v.op, v.fun, I(v.a), I(v.b)),
				Unary v => new Unary(pos, v.op, v.fun, I(v.a)),
				Variable v => (v.name == param ) ? arg : v,
				FunCall v => new FunCall(pos, I(v.fun), I(v.arg)),
				Lambda v when v.param == param => v,
                Lambda v => new Lambda(pos, v.param, I(v.body)),
				Assign v when v.name == param =>
					throw new EvalException(pos, "Can't reassign parameter"),
				Assign v => new Assign(pos, v.name, I(v.val)),
				Or v => new Or(pos, I(v.a), I(v.b)),
				And v => new And(pos, I(v.a), I(v.b)),
				If v => new If(pos, I(v.cond), I(v.t), I(v.f)),
				Builtin b => b,
				_ => throw new NotImplementedException(),
			};
            // Console.WriteLine($"bound {param} = {res}");
            return res;
		}
	}
}
